package cn.com.xinli.portal.controller;

import cn.com.xinli.portal.auth.AccessAuthentication;
import cn.com.xinli.portal.core.*;
import cn.com.xinli.portal.support.rest.RestResponse;
import cn.com.xinli.portal.support.rest.RestResponseBuilders;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler;

/**
 * Spring web MVC controller advice.
 * <p>
 * This class handles all uncaught exceptions (includes checked and unchecked),
 * wraps exceptions into error response JSON.
 * <p>Unhandled exception thrown from REST controllers will be
 * handled here. By default, it will return a {@link Error} contains additional
 * information about what's going on of the PWS.
 * <p>
 * If incoming requests came with authentication in the http header,
 * server should respond with authentication results even if those
 * requests resulting in errors.
 * <p>
 * Authentication exceptions thrown from server do not come from
 * any controllers, those exceptions may be thrown by spring-security framework,
 * or custom {@link javax.servlet.Filter}s,
 * {@link org.springframework.web.servlet.HandlerInterceptor}
 * and other in-house infrastructures.
 * <p>
 * Project: xpws
 *
 * @author zhoupeng 2015/12/19.
 */
@Service
@ControllerAdvice(basePackages = "cn.com.xinli.portal.controller")
public class RestExceptionAdvisor extends ResponseEntityExceptionHandler {
    /**
     * Logger.
     */
    private final Logger logger = LoggerFactory.getLogger(RestExceptionAdvisor.class);

    /**
     * REST controller platform exception handler.
     * <p>
     * {@link PlatformException}s are generated by portal service
     * platform nodes, including NAS/BRAS, AAA.
     * <p>
     * This function will return a HTTP 403 status with
     * a {@link Error} JSON inside http response body.
     *
     * @param e {@link RuntimeException}
     * @return {@link RestResponse}
     */
    @ResponseStatus(value = HttpStatus.FORBIDDEN)
    @ResponseBody
    @ExceptionHandler(value = {PlatformException.class})
    public RestResponse handlePlatformException(PlatformException e) {
        if (logger.isDebugEnabled()) {
            logger.error("handle exception: {} ", e.getMessage());
        }

        return RestResponseBuilders.errorBuilder()
                .setError(e.getPortalError())
                .setDescription(e.getMessage())
                .setUrl("/error")
                .build();
    }

    /**
     * Session not found exception handler.
     * <p>
     * This function will return a HTTP 404 status with
     * a {@link Error} JSON inside http response body.
     * @param e {@link SessionNotFoundException}
     * @return response json object.
     */
    @ResponseStatus(value = HttpStatus.NOT_FOUND)
    @ResponseBody
    @ExceptionHandler(value = {SessionNotFoundException.class})
    public RestResponse handleSessionNotFoundException(SessionNotFoundException e) {
        if (logger.isDebugEnabled()) {
            logger.error("handle exception: {} ", e.getMessage());
        }

        /* In case that request came with authentication. */
        AccessAuthentication authentication =
                (AccessAuthentication) SecurityContextHolder.getContext().getAuthentication();

        return RestResponseBuilders.successBuilder()
                .setAccessAuthentication(authentication)
                .build();
    }

    /**
     * REST API remote exception handler.
     * <p>
     * This function will return a HTTP 403 status with
     * a {@link Error} JSON inside http response body.
     * @param e {@link RemoteException}
     * @return response json object.
     */
    @ResponseStatus(value = HttpStatus.FORBIDDEN)
    @ResponseBody
    @ExceptionHandler(value = {RemoteException.class})
    public RestResponse handleRemoteException(RemoteException e) {
        if (logger.isDebugEnabled()) {
            logger.error("handle exception: {} ", e.getMessage());
        }

        /* In case that request came with authentication. */
        AccessAuthentication authentication =
                (AccessAuthentication) SecurityContextHolder.getContext().getAuthentication();

        return RestResponseBuilders.errorBuilder()
                .setError(e.getPortalError())
                .setAccessAuthentication(authentication)
                .setDescription(e.getMessage())
                .build();
    }

    /**
     * REST API access denied exception handler.
     * <p>
     * For some reason, incoming request pass authentication check, i.e. got an
     * anonymous role, and try to access restricted controller methods.
     * {@link AccessDeniedException} will be thrown by spring-security framework.
     * In this case, server should response HTTP 403 FORBIDDEN, and an error
     * json result inside http entity.
     * <p>
     * {@link AccessDeniedException}s thrown by spring-security framework are
     * NOT defined by server, so it's impossible to get portal error out it,
     * we should translate this exception to portal error and then send to
     * remote client.
     * <p>
     * This function will return a HTTP 403 status with
     * a {@link Error} JSON inside http response body.
     *
     * @param e {@link AccessDeniedException}
     * @return response json object.
     */
    @ResponseStatus(value = HttpStatus.FORBIDDEN)
    @ResponseBody
    @ExceptionHandler(value = {AccessDeniedException.class})
    public RestResponse handleAccessDeniedException(AccessDeniedException e) {
        if (logger.isDebugEnabled()) {
            logger.error("handle exception: {} ", e.getMessage());
        }

        return RestResponseBuilders.errorBuilder()
                .setError(PortalError.of("unauthorized_request"))
                .setDescription(e.getMessage())
                .build();
    }

    /**
     * Server internal exception handler.
     * <p>
     * Server internal exceptions indicate that something went wrong on server,
     * this should not happen. When server respond {@link ServerException} to
     * remote client, client should report this exception to the server developers,
     * so that they can figure out what and why server went wrong,
     * they can also find potential bugs and issues and try to fix them.
     * <p>
     * This function will return a HTTP 500 status with
     * a {@link Error} JSON inside http response body.
     *
     * @param e {@link AccessDeniedException}
     * @return response json object.
     */
    @ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR)
    @ResponseBody
    @ExceptionHandler(value = {ServerException.class})
    public RestResponse handleServerException(ServerException e) {
        if (logger.isDebugEnabled()) {
            logger.error("handle exception: {} ", e.getMessage());
        }

        return RestResponseBuilders.errorBuilder()
                .setError(e.getPortalError())
                .setDescription(e.getMessage())
                .build();
    }

    /**
     * Server runtime exception handler.
     * <p>
     * Same as {@link ServerException}, {@link RuntimeException} also should not
     * happen. When it happens, server responds with HTTP 500 and
     * an additional text message describe server internal error.
     * Users should report errors to server developers.
     * <p>
     * This function will return a HTTP 500 status with
     * a {@link Error} JSON inside http response body.
     *
     * @param e runtime exception.
     * @return response json object.
     */
    @ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR)
    @ResponseBody
    @ExceptionHandler(value = {RuntimeException.class})
    public RestResponse handleServerException(RuntimeException e) {
        if (logger.isDebugEnabled()) {
            logger.error("handle exception: {} ", e.getMessage());
        }

        return RestResponseBuilders.errorBuilder()
                .setError(PortalError.of("server_internal_error"))
                .setDescription(e.getMessage())
                .build();
    }
}
